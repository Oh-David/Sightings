input AMPLIFY {
  globalAuthRule: AuthRule = { allow: public }
} # FOR TESTING ONLY!
type User @model @auth(rules: [{ allow: owner }]) {
  id: ID!
  username: String!
  email: String
  items: [Item] @hasMany(indexName: "itemsByUser", fields: ["id"])
}

type Query {
  listPublicItems(limit: Int): ModelItemConnection
}

type Item
  @model
  @auth(
    rules: [
      { allow: owner } # Owners can read, update, and delete their items
      { allow: public, operations: [read], provider: iam } # All users can read public items
    ]
  ) {
  id: ID!
  title: String!
  description: String
  images: [String]
  isPublic: String!
  price: Float
  userID: ID! @index(name: "itemsByUser")
  user: User @belongsTo(fields: ["userID"])
  offers: [Offer] @hasMany(indexName: "offersByItem", fields: ["id"])
}

type Offer @model @auth(rules: [{ allow: owner, operations: [read] }]) {
  id: ID!
  itemID: ID! @index(name: "offersByItem")
  item: Item @belongsTo(fields: ["itemID"])
  offeredByUserID: ID!
  offeredToUserID: ID!
  status: String
}

input ModelItemFilterInput {
  id: ModelIDInput
  title: ModelStringInput
  description: ModelStringInput
  images: ModelStringInput
  isPublic: ModelStringInput
  price: ModelFloatInput
  userID: ModelIDInput
  # add other fields as necessary
}

type ModelItemConnection {
  items: [Item]
  nextToken: String
}

input ModelIDInput {
  eq: ID
  ne: ID
  le: ID
  lt: ID
  ge: ID
  gt: ID
  contains: ID
  notContains: ID
  between: [ID]
  beginsWith: ID
}

input ModelStringInput {
  eq: String
  ne: String
  le: String
  lt: String
  ge: String
  gt: String
  contains: String
  notContains: String
  between: [String]
  beginsWith: String
}

input ModelBooleanInput {
  eq: Boolean
  ne: Boolean
}

input ModelFloatInput {
  eq: Float
  ne: Float
  le: Float
  lt: Float
  ge: Float
  gt: Float
  between: [Float]
}
